name: Terraform Module Version Checker

on:
  workflow_dispatch:
  schedule:
    - cron: '0 10 * * *'  # Run every day at 7AM - Argentina

permissions:
  contents: read
  issues: write

jobs:
  check_versions:
    runs-on: ubuntu-latest

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üõ†Ô∏è Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: latest

      - name: üöÄ Run version checker
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          INPUT_FILE="example/complete/modules.plain"
          OUTPUT_FILE="version_report.md"
          TMP_FILE=".modules_cleaned.tmp"
          ISSUE_FILE=".module_issues.txt"

          echo "üîÑ Generating fresh module list from 'terraform modules'..."
          terraform init -input=false -backend=false > /dev/null
          terraform modules > "$INPUT_FILE"

          if [[ $? -ne 0 ]]; then
            echo "‚ùå Failed to generate $INPUT_FILE using 'terraform modules'. Aborting."
            exit 1
          fi

          grep -E '\[registry\.terraform\.io' "$INPUT_FILE" | \
          sed -E 's/^[^"]*"([^"]+)"\[(registry\.terraform\.io[^]]+)\][[:space:]]+([0-9]+\.[0-9]+\.[0-9]+).*$/\1|\2|\3/' > "$TMP_FILE"

          echo "# üì¶ Terraform Module Version Report" > "$OUTPUT_FILE"
          echo "_Generated on $(date)_" >> "$OUTPUT_FILE"
          echo "" >> "$OUTPUT_FILE"
          > "$ISSUE_FILE"

          while IFS="|" read -r MODULE_NAME MODULE_PATH USED_VERSION; do
            MODULE_NAME=$(echo "$MODULE_NAME" | sed 's/^module\.//; s/ *$//')
            MODULE_PATH=$(echo "$MODULE_PATH" | xargs)
            USED_VERSION=$(echo "$USED_VERSION" | xargs | sed 's/^[^0-9]*//')

            if [[ -z "$MODULE_PATH" || "$MODULE_PATH" != registry.terraform.io/* ]]; then
              continue
            fi

            MODULE_PATH_CLEAN=$(echo "$MODULE_PATH" | sed -E 's,//modules.*,,')
            IFS='/' read -r _ namespace name provider <<< "$MODULE_PATH_CLEAN"

            if [[ -z "$namespace" || -z "$name" || -z "$provider" ]]; then
              echo "‚ö†Ô∏è Skipping malformed entry: $MODULE_PATH" | tee -a "$OUTPUT_FILE"
              continue
            fi

            API_URL="https://registry.terraform.io/v1/modules/${namespace}/${name}/${provider}/versions"
            RESPONSE=$(curl -s "$API_URL")

            if [[ -z "$RESPONSE" || "$RESPONSE" == "null" ]]; then
              echo "‚ö†Ô∏è Failed to fetch latest version for \`${MODULE_PATH}\` (API error)" | tee -a "$OUTPUT_FILE"
              continue
            fi

            LATEST_VERSION=$(echo "$RESPONSE" | jq -r '.modules[0].versions | map(.version) | sort | last')

            if [[ -z "$LATEST_VERSION" || "$LATEST_VERSION" == "null" ]]; then
              echo "‚ö†Ô∏è Could not determine latest version for \`${MODULE_PATH}\`" | tee -a "$OUTPUT_FILE"
              continue
            fi

            if [[ "$USED_VERSION" == "$LATEST_VERSION" ]]; then
              echo "‚úÖ \`${MODULE_PATH}\` is up to date (**$USED_VERSION**)" | tee -a "$OUTPUT_FILE"
            else
              echo "‚ùå \`${MODULE_PATH}\` is outdated (used: **$USED_VERSION**, latest: **$LATEST_VERSION**)" | tee -a "$OUTPUT_FILE"
              echo "${MODULE_NAME}|${namespace}/${name}/${provider}|${USED_VERSION}|${LATEST_VERSION}" >> "$ISSUE_FILE"
            fi
          done < "$TMP_FILE"

          rm -f "$TMP_FILE"

          if [[ -s "$ISSUE_FILE" ]]; then
            echo "outdated=true" >> "$GITHUB_OUTPUT"
          else
            echo "outdated=false" >> "$GITHUB_OUTPUT"
          fi

      - name: üõ†Ô∏è Install GitHub CLI (gh)
        if: steps.check.outputs.outdated == 'true'
        run: |
          type -p gh || (
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg && \
            sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg && \
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null && \
            sudo apt update && sudo apt install gh -y
          )
          gh --version

      - name: üêõ Create or update issues for outdated modules
        if: steps.check.outputs.outdated == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          while IFS="|" read -r pattern module used latest; do
            title="Upgrade(${pattern}): ${module} (${used} > ${latest})"

            echo "üîç Searching for existing issue for $module"
            issue_data=$(gh issue list --state open --search "$pattern" --json title,number --jq \
              '.[] | select(.title | contains("'"$pattern"'"))')

            if [[ -z "$issue_data" ]]; then
              echo "üÜï Creating issue: $title"
              gh issue create \
                --title "$title" \
                --body "The module \`${module}\` is outdated.\n\n- Pattern: \`${pattern}\`\n- Used: \`${used}\`\n- Latest: \`${latest}\`" \
                --label terraform
            else
              number=$(echo "$issue_data" | jq -r '.number')
              old_title=$(echo "$issue_data" | jq -r '.title')

              if [[ "$old_title" != *"$latest"* ]]; then
                echo "‚úèÔ∏è Updating issue #$number with new version"
                gh issue edit "$number" \
                  --title "$title" \
                  --body "The module \`${module}\` is outdated.\n\n- Pattern: \`${pattern}\`\n- Used: \`${used}\`\n- Latest: \`${latest}\`"
              else
                echo "‚úÖ Issue already exists and is up to date for $pattern"
              fi
            fi
          done < .module_issues.txt
